# 모던자바스크립트 DeepDive 14장 : 전역변수의 문제점

## 개요

**전역변수의 무분별한 사용은 위험하다**

- 전역변수를 반드시 사용해야 할 이유를 찾지 못하겠다면 지역변수를 사용해야한다

## 변수의 생명주기

### 지역변수의 생명주기

**변수는 선언에 의해 생성되고 할당을 통해 값을 가진다 그리고 언젠가 소멸한다**

- 즉, 변수는 생물과 유사하게 생성되고 소멸되는 생명주기를 가지고 있다
- 변수는 자신이 선언된 위치에서 생성되고 소멸한다
- 전역변수의 생명주기는 애플리케이션의 생명주기와 동일하다
  - 하지만 함수내부에 선언된 지역변수는 함수가 호출하면 생성되고 함수가 종료하면 소멸한다
- 아래코드에서 지역변수 `x`는 `functionLocalVaribale` 함수가 호출되기 전까진 생성되지 ❌

```jsx
/* 지역변수의 생명주기 */
function functionLocalVaribale() {
  var x = "local";
  console.log(x); // 'local'
  return x;
}

functionLocalVaribale();

/* Reference Error */
console.log(x);
```

**변수 선언은 선언문이 어디에있는지 상관없이 가장 먼저 실행된다**

- 런타임에 실행되는 것이아닌 런타임 이전 단계에서 자바스크립트 엔진에 의해 먼저 실행되는 것
- 그러나 엄밀히 말하자면 위 설명은 전역 변수에 한정
  - 함수 내부에 선언한 변수는 함수가 호출된 직후 함수 몸체의 코드가 한줄씩 순차적으로 실행되기 이전에 자바스크립트 엔진에 의해 먼저 실행되고 있다
- 위 코드에서 `functionLocalVaribale` 함수 호출 시 함수 몸체 다른 문들이 순차적으로 실행되기 이전에
  - `x` 변수의 선언문이 엔진에 의해 가장 먼저 실행되어 `x`변수가 선언되고
  - `undefined`로 초기화 된다
- 그 후, 함수 몸체를 구성하는 문들이 순차적으로 실행되며 변수 할당문이 실행되면
  - `x` 변수에 값 ‘local’이 할당된다
- 그리고 함수 종료 시 `x` 변수도 소멸되어 생명주기를 마감한다
- 따라서 함수 내부 선언된 지역변수 `x`는 함수의 생명주기와 일치된다

**함수 몸체 내부에서 선언된 지역변수가 함수보다 오래 생존하는 경우**

- 클로저
  - 누군가가 스코프를 참조하고 있으면 스코프는 해제되지 않고 생존하게 된다

**아래코드에서 변수 x가 출력되는 값은?**

- 정답은 `undeinfed`
- `foo` 함수 내부 선언된 지역변수 `x`는 콘솔로그를 만난 시점에 이미 선언되었고 `undefined`로 초기화 되어 있다
  - 따라서 전역변수 `x`를 참조하는 것이 아닌 지역변수 `x`를 참조해 값을 가진다
- 이처럼 호이스팅은 스코프를 단위로 동작
  - 전역변수는 전역전체에서 유효하고
  - 지역변수의 호이스팅은 지역변수의 선언이 지역스코프의 선두로 끌어 올려진것처럼 동작
- 즉, 호이스팅은 변수 선언이 스코프의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트의 특징

```jsx
/* 아래코드에서 변수 x가 출력되는 값은? */
var x = "global";

function foo() {
  console.log(x); // undefined
  var x = "local";
}

foo();
console.log(x); // 'global'
```

### 전역변수의 생명주기

**함수와 달리 전역코드는 명시적인 호출 없이 실행**

- 코드가 로드되자마자 곧바로 파싱되고 실행
- 전역코드는 반환문을 사용할 수 없으므로 마지막에 문이 실행되어 더이상 실행할 문이 없을 경우 종료
- `var`로 선언한 전역변수는 전역 객체의 프로퍼티가 된다
  - 이는 전역변수의 생명주기가 전역객체의 생명주기가 일치하다는 증거이다

## 전역변수의 문제점

**암묵적 결합**

- 전역 변수를 선언한 의도는 코드 어디서든 참조하고 할당할 수 있는 변수를 사용하겠다는 의미
- 이는 모든 코드가 전역변수를 참조하거 변경할 수 있는 암묵적 결합을 허용하겠다는 것
- 변수의 유효범위가 커질 수록 코드의 가독성은 나빠지고 의도치않게 상태가 변경될 수 있는 가능성이 존재한다

**긴 생명주기**

- 전역변수는 생명주기도 길다
  - 따라서 메모리 리소스 또한 오랜기간 소비한다
  - 전역변수의 상태를 변경할 수 있는 시간도 길고 기회도 많아진다
- 더욱이 `var` 키워드는 변수의 중복선언을 허용하므로 생명주기가 긴 전역변수는 변수의 이름까지 중복될 가능성이 있다
  - 중복 시 의도치 않은 재할당이 이루어질 가능성이 존재한다

```jsx
var x = 1;

/* 변수의 중복선언 기존의 값을 재할당하고 있다 */
var x = 1000;

console.log(x); // 1000
```

**스코프 체인 상에 종점에 존재**

- 전역변수는 스코프체인 상의 종점에 존재
  - 이는 변수 검색 시 전역변수가 가장 마지막에 검색된다는 것을 뜻한다
- 즉, 전역변수의 검색속도는 가장 느리다

**네임스페이스 오염**

- 자바스크립트는 파일이 분리되어 있다해도 하나의 전역스코프를 공유한다는 점
  - 따라서 다른 파일 내 동일한 이름으로 명명된 전역변수나 전역함수가 같은 스코프의 존재할 경우 예상치 못한 결과를 초래할 가능성이 생긴다

## 전역 변수의 사용을 억제하는 방법

### 즉시 실행 함수

**즉시실행 함수 사용**

- 모든 코드를 즉시 실행 함수로 감싸면 모든 변수는 즉시 실행 함수의 지역변수가 된다
- 이러한 특성을 이용해 전역 변수의 사용을 제한할 수 있다

```jsx
/* IIFE */
(() => {
  var iifeVariable = 10;
})();

/* ReferenceError  */
console.log(iifeVariable);
```

### 네임스페이스 객체

**전역에 네임스페이스 역할을 담당할 객체 생성**

- 전역변수처럼 사용하고 싶은 변수를 프로퍼티로 추가하는 방법

```jsx
/* 네임스페이스 */

var APP = {};

APP.name = "seju";
console.log(APP.name); // 'seju'
```

**네임스페이스 객체에 또 다른 네임스페이스 객체를 추가할 수 도 있다**

- 이러한 방법으로 네임스페이스 객체를 계층적으로 구성
- 그러나 이러한 방법들은 네임스페이스 객체 자체가 전역변수에 해당되므로 유용하지 않다

```jsx
var APP = {};

APP.person = {
  name: "손흥민",
  age: "33",
};

console.log(APP.person.name); // 손흥민
```

### 모듈 패턴

**모듈패턴이란?**

- 관련이 있는 변수와 함수를 모아 즉시실행함수로 감싸 하나의 모듈을 만드는 것
- 모듈 패턴은 클로저를 기반으로 동작
- 전역변수의 억제 및 캡슐화 까지도 구현이 가능하다
- 아래 코드에서 즉시 실행함수는 객체를 반환한다
  - 해당 객체는 외부에 노출하고 싶은 변수나 함수를 담아 반환
    - 반환된 객체는 외부에 노출되는 퍼블릭멤버
    - 외부로 노출하고 싶지 않은 변수나 함수에 대해선 프라이빗 멤버가 된다

```jsx
/* 모듈 패턴 */
var counter = (() => {
  var num = 0;

  return {
    increase() {
      return ++num;
    },
    decrease() {
      return --num;
    },
  };
})();

console.log(counter.increase()); // 1
console.log(counter.increase()); // 2
console.log(counter.decrease()); // 1
console.log(counter.decrease()); // 1
console.log(counter.decrease()); // 1
```

### ES6 모듈

**ES6부턴 모듈을 사용할 수 있다**

- ES6 모듈은 파일 자체의 독자적인 모듈 스코프를 제공
  - 따라서 모듈 내 `var`로 선언한 변수는 더이상 전역변수가 아니며 `window` 객체의 프로퍼티도 아니다

```tsx
<script type"module"></script>
```
