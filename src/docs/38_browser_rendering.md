# 모던자바스크립트 DeepDive 38장 브라우저의 렌더링 과정

# 개요

**구글 자바스크립트 엔진 런타임 환경 Node.js**

- 자바스크립트는 웹 브라우저를 벗어나 서버 사이드 애플리케이션 개발에도 사용할 수 있는 개발언어가 됨
- 그러나 역시 가장 많이 사용되는 영역은 웹페이지/애플리케이션의 클라이언트 사이드
- 이를 위해 브라우저가 HTML,CSS,JavaScript로 작성된 텍스트 문서를 어떻게 파싱하여 브라우저에 렌더링을 하는지 알아야 할 필요가 있다

> 💡 **브라우저 렌더링 과정**

1. 브라우저는 HTML,CSS,JavaScript,이미지,폰트 등 렌더링에 필요한 리소스를 요청 및 서버로부터 응답받는다
2. 브라우저의 렌더링 엔진은 서버로부터 응답 된 HTML과 CSS를 파싱해 DOM과 CSSOM을 생성하고 이들을 결합하여 렌더트리를 생성한다
3. 서버로부터 응답된 자바스크립트를 파싱해 AST(Abstarct Synctax Tree)를 생성, 바이트코드로 변환해 실행한다. 이때 자바스크립트는 DOM API를 통해 DOM과 CSSOM을 변경할 수 있다
4. 렌더 트리를 기반으로 HTML 요소의 레이아웃을 계산하고 브라우저 화면에 HTML 요소를 페인팅한다

## 요청과 응답

**브라우저의 핵심기능은?**

- 필요한 리소스를 서버에 요청하고 서버로부터 응답받아 브라우저에 시각적으로 렌더링하는 것
- 서버에 요청을 전송하기 위해 브라우저는 주소창을 제공
  - 주소창에 URL을 입력하면 URL의 호스트 이름이 DNS를 통해 IP주소로 변환되고 이 IP 주소를 갖는 서버에게 요청을 전송한다
- 일반적으로 서버는 루트요청에 대해 암묵적으로 index.html을 응답하도록 기본설정 되어 있다
  - `https://poienweb.com === https://poienweb.com/index.html` 이 동일하다
- 따라서 서버는 루트요청에 대해 서버의 루트 폴더에 존재하는 정적 파일인 index.html을 클라이언트로 응답한다
- 그러나 반드시 브라우저의 주소창을 통해 서버에게 정적파일을 요청할 수 있는것은 ❌
  - 자바스크립트를 통해서도 가능 (ajax,RESTAPI)

## HTTP 1.1과 HTTP 2.0

**HTTP란?**

- 웹에서 브라우저와 서버가 통신하기 위한 프로토콜

### HTTP/1.1

**커넥션당 하나의 요청과 응답만 처리**

- 따라서 HTML 문서 내 여러개의 리소스 요청이 개별적으로 전송되고 응답 또한 개별적으로 전송됨
  - 요청할 리소스의 개수에 비례해 응답시간도 증가하는 단점 초래

### HTTP/2.0

**커넥션 당 여러개의 요청과 응답**

- HTTP 1.1과 다르게 다중요청 및 응답이 가능하다
- HTTP 1.1에 비해서 페이지 로드 속도가 50% 가량 빠르다

![*HTTP1.1 과 HTTP 2.0의 차이*](/assets/docs/38_broweser_rendering/image1.png)

_HTTP1.1 과 HTTP 2.0의 차이_

## HTML 파싱과 DOM 생성

**브라우저에 요청에 의해 서버가 응답한 HTML 문서는 문자열로 이루어진 순수한 텍스트**

- 순수한 텍스트를 브라우저에 시각적인 UI로 렌더링하려면 HTML문서를 브라우저가 이해할 수 있는 자료구조로 변환해 메모리에 저장해야한다

**HTML 파싱과 DOM 생성**

- 브라우저가 이해할 수 있는 자료구조 ➡️ `**DOM**`
  - **DOM은 HTML 문서를 파싱한 결과물**

![*HTML 파싱과 DOM 생성*](/assets/docs/38_broweser_rendering/image2.png)

_HTML 파싱과 DOM 생성_

## CSS 파싱과 CSSOM 생성

**렌더링 엔진**

- `HTML`을 한줄 씩 순차적으로 파싱해 `DOM`을 생성해 나간다
  - 생성해나가다 `CSS`를 로드하는 `link`태그나 `style` 태그를 만나면 `DOM` 생성을 일시 중지함
- `link` 태그의 `href` 어트리뷰트를 통해 `CSS` 파일을 서버에 요청하여 로드한 `CSS` 파일이나 `style` 태그 내의 `CSS`를 `HTML`과 동일한 파싱 과정을 거치며 해석하여 `CSSOM`을 생성
- 이후 `CSS` 파싱 완료 시 `HTML` 파싱이 중단된 지점 부터 다시 `HTML`을 파싱하기 시작해 `DOM` 생성을 재개

**CSSOM 생성 과정**

- 서버로부터 `CSS` 파일 응답 시 렌더링 엔진은 동일한 파싱과정을 거쳐 `CSSOM`을 생성한다
  - CSSOM은 CSS의 상속을 반영해 생성된다

![*CSSOM 생성*](/assets/docs/38_broweser_rendering/image3.png)

_CSSOM 생성_

## 렌더 트리 생성

**렌더트리란?**

- 렌더링을 위한 트리구조의 자료구조
  - 렌더트리는 브라우저의 화면에 렌더링되는 노드만으로 구성 (`display:none`과 같은 노드들은 포함 ❌)
- 서버로 부터 응답된 `DOM`과 `CSSOM`을 생성하고 렌더링을 위헤 **렌더트리로 결합**된다
- 이후 최종적으로 완성된 렌더트리는 각 HTML 요소의 레이아웃을 계산하는데 사용되며 브라우저의 화면에 픽셀을 렌더링하는 페인팅 처리에 입력된다

![*브라우저의 렌더링 과정*](/assets/docs/38_broweser_rendering/image4.png)

_브라우저의 렌더링 과정_

**브라우저의 렌더링 과정은 반복해서 실행될 수도 있다**

- 자바스크립트에 의한 노드 추가 및 삭제
- 브라우저 창의 리사이징에 의한 뷰포트 크기 변경
- HTML 요소와 레이아웃에 변경을 발생 시키는 `width/height, margin, padding, border ,display, position, top/right/bottom/letf`등의 스타일 변경
  - 레이아웃 계산과 페이팅을 다시 실행하는 리렌더링은 성능에 악영향을 주는 작업
  - 가급적 리렌더링이 발생하지 않도록 주의

## 자바스크립트 파싱과 실행

**HTML 문서를 파싱한 결과물로 생성된 DOM**

- HTML 요소와 스타일등을 변경할 수 있는 `DOM API` 제공

**렌더링 엔진 동작 시 JavaScript를 만나면?**

- DOM 생성을 일시 중단하고 제어권을 자바스크립트 엔진으로 넘긴다
- 자바스크립트 파싱과 실행 종료 시 렌더링 엔진으로 제어권을 다시 넘겨 `HTML`의 파싱이 중단된 지점부터 `HTML` 파싱을 시작해 `DOM` 생성을 재개한다

**자바스크립트 파싱과 실행**

- 브라우저의 렌더링 엔진이 아닌 자바스크립트 엔진이 처리
  - 엔진은 코드를 파싱해 CPU가 이해할 수 있는 저수준 언어로 변환하고 실행하는 역할
    - Chrome,Node.js,V8,파이어폭스,사파리등 존재
    - 모든 엔진은 ECMAScript 사양을 준수함
- **자바스크립트 엔진은 자바스크립트를 해석해 AST를 생성**한다
- AST를 기반으로 인터프리터가 실행할 수 있는 중간코드인 바이트 코드를 생성하여 실행

![*자바스크립트 파싱과 실행*](/assets/docs/38_broweser_rendering/image5.png)

_자바스크립트 파싱과 실행_

**토크나이징**

- 단순한 문자열인 자바스크립트 소스코드를 분석해 문법적 의미를 가지는 최소단위인 토큰들로 분해
- 이과정을 렉싱이라고 부르기도하지만 토크나이징과 미묘한 차이가 존재

**파싱**

- 토큰들의 집합을 구문분석해 AST(추상적 구문트리) 생성
  - AST는 토큰에 문법적 의미와 구조를 반영한 트리구조의 자료구조
- AST를 사용하면 TypeScript,Babel,Pritter와 같은 트랜스파일러도 구현 가능

**바이트코드 생성과 실행**

- 파싱의 결과물로 생성된 AST는 인터프리터가 실행할 수 있는 중간코드인 바이트코드로 변환
- 인터프리터에의해 실행

## 리플로우와 리페인트

**리플로우/리페인트란?**

- 자바스크립트 코드에 DOM이나 CSSOM을 변경하는 DOM API 사용 시 DOM이나 CSSOM이 변경
- 이때 **변경된 DOM과 CSSOM은 다시 렌더트리로 결합되고 변경된 렌더트리를 기반으로 레이아웃과 페인트 과정을 거쳐 화면에 리렌더링**
  - 이러한 과정을 **리플로우,리페인트**라 함

## 자바스크립트 파싱에 의한 HTML 파싱 중단

**렌더링엔진과 자바스크립트엔진은 직렬적으로 파싱을 수행**

- 브라우저는 동기적(`synchronous`)
  - 위에서 아래로 순차적으로 HTML,CSS,자바스크립트를 파싱하고 실행
  - 따라서, `script` 태그의 위치에 따라 `HTML` 파싱이 블로킹 되 `DOM` 생성이 지연될 수 있음을 의미
  - `script` 태그 내 `DOM API`를 사용하면? 하단의 `DOM`트리를 읽지못한다
  - `script` 태그를 `body` 맨 뒤에 위치시키거나 OR `async/defer` 어트리뷰트를 사용해야한다

![*직렬적 파싱*](/assets/docs/38_broweser_rendering/image6.png)

_직렬적 파싱_

### script태그의 async/defer 어트리뷰트

**async/defer**

- 자바스크립트 파싱에 의한 `DOM` 생성이 중단되는 문제를 해결하기위한 어트리뷰트
- 인라인 자바스크립트에서는 사용 ❌

```jsx
/* async/defer  */

<script async src="example.js"></script>
<script defer src="example.js"></script>

```

**async 어트리뷰트**

- HTML 파싱과 외부 자바스크립트 파일의 로드가 비동기적으로 동시에 진행
  - 단, 자바스크립트 파싱과 실행은 자바스크립트 파일의 로드가 완료된 후 진행되며, 이때 `HTML`파싱이 중단된다

![*async 어트리뷰트*](/assets/docs/38_broweser_rendering/image7.png)

_async 어트리뷰트_

**defer 어트리뷰트**

- async와 마찬가지로, HTML 파싱과 외부 자바스크립트 파일의 로드가 비동기적으로 동시에 진행
- 차이점은 자바스크립트의 파싱과 실행은 `DOM` 생성이 완료된 직후 진행(이때 `DOMContentLoaded` 이벤트 발생)
  - 따라서 DOM 생성이 완료된 이후 실행되어야할 자바스크립트에 유용

![*defer 어트리뷰트*](/assets/docs/38_broweser_rendering/image8.png)

_defer 어트리뷰트_
